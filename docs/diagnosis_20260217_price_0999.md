# 2026-02-17 价格被识别为 0.999 的根因定位（基于主日志 + 单 token 日志）

## 结论（更精准版本）
本次 `0.999/0.99` 不是单一解析 bug，而是**“异常盘口输入 + WS 净化后的旧价保留 + REST 校验强制覆盖”**形成的闭环：

1. 主程序日志明确出现该 token 的异常盘口：`bid=0.001 ask=0.999 last=0.059`，被 `QUOTE_SANITY` 判为异常并跳过。  
2. 单 token 进程在共享 WS 中长期看到 `best_ask=0.059`，随后反复打印 `卖一校验覆盖（上行) old=0.059 new=0.999`。  
3. 代码中卖一校验逻辑是“只要差值超过 tolerance 就覆盖”，没有跳变闸门/连续确认机制。  
4. 在你这个样本里，0.999 只在首次挂单出现一次，之后大量实际挂单状态停留在 `0.153`，说明“校验日志频繁触发”与“最终报价”已经解耦，覆盖事件本身被后续策略重定价抵消。

## 证据链

### A. 0.999 异常盘口确实存在于 WS 输入层
- 主日志出现：`token=85831265... reason=spread_ratio_too_wide:1.996 bid=0.001 ask=0.999 last=0.059`。  
- 同一批还有大量 token 的 `0.99/0.999` 边缘盘口被检测到。

### B. 单 token 侧 WS 看到的是低价快照（0.059）
- 单 token 日志启动时读取共享缓存：`bid=0.058, ask=0.059`。
- 后续持续以 `old=0.059` 对比出 `new=0.999`，反复触发“卖一校验覆盖（上行）”。

### C. 覆盖策略在代码层是“超容差即替换”
- `maker_execution.py` 中：
  - 定时触发 `validated = _fetch_best_price(..., "ask")`；
  - 若 `abs(validated_price - ask) > tolerance`，直接 `ask = validated_price` 并打印“卖一校验覆盖（上行/下行）”；
  - 未见“最大允许跳变”“连续 N 次确认”或“接近 price_cap 的特殊拒绝”。

### D. 本次样本里“频繁覆盖”与“最终挂单价”不一致
- 单 token 日志中首次出现 `挂单 -> price=0.999` 后，很快转为 `挂单 -> price=0.153`；
- 后续大量状态行为 `挂单状态 -> price=0.153`，但覆盖日志仍不断出现。
- 这说明 `0.999` 主要污染了“校验信号层”，未持续主导最终卖单价格，但会造成噪声、错误判断和潜在策略抖动。

## 为什么你会感到“到处都在 0.99/0.999”
主日志中运行状态汇总里，出现了大量 `old=x new=0.99/0.999` 的最后一行，且 old 分布很宽（低到 0.031、高到 0.85）。这更像是统一校验链路的系统性行为，而不是单市场单 token 的偶发异常。

## 关键代码点（定位）
1. **异常盘口识别与处理**（聚合器）
   - `_detect_suspicious_quote()` 会将超宽价差（如 `0.001/0.999`）判异常。
   - `on_book_or_price()` 中对异常盘口的处理，可能“跳过新 token 更新”或“回退到旧盘口”。

2. **卖一校验覆盖**（执行器）
   - `maker_sell_follow_ask()` 中的 `ask_validation_interval` 分支：REST 校验只要与当前 ask 差异超容差就覆盖。

3. **宽松提取器风险仍然存在**（次因）
   - `_extract_best_price()` 最后存在 `for value in payload.values()` 的全量递归兜底，确实可能误命中非目标字段。
   - 但在本次日志里，已能独立证明“0.999 在输入层真实出现”，因此“解析误提取”不是唯一解释，最多是放大器。

## 更新后的修复优先级（从高到低）

### P0（必须先做）
1. **给卖一校验覆盖加“跳变闸门 + 连续确认”**
   - 若 `validated_price / local_ask` 跨度过大（例：>30% 或 >N tick）先进入可疑态，不立即覆盖；
   - 连续 2~3 次 REST 一致且时间上连续，才允许覆盖；
   - `validated_price >= 0.98` 且与 `last_trade/mid` 偏差过大时，强制拒绝覆盖并告警。

2. **结构化记录校验来源**
   - 覆盖日志加字段：`token_id / local_ask / validated_ask / source(local/rest) / cache_age / ws_seq / payload_path`。
   - 目标：下次 1 次日志就能判定“真实盘口跃迁”还是“脏源/误解析”。

### P1（高优先）
3. **收紧 `_extract_best_price`**
   - 去掉最终 `payload.values()` 的无限兜底；
   - 仅允许白名单路径（如 `asks[0].price`, `bestAsk`）；
   - 若响应含 token/asset 标识，必须与请求 token 匹配。

4. **让 WS 异常净化与卖出校验共享同一套 sanity gate**
   - 现在 WS 层已经能识别异常盘口；
   - 卖出校验覆盖前也应执行同样规则（spread、mid 偏离、edge quote），避免“WS 拒绝但 REST 直接接纳”。

### P2（稳定性增强）
5. **缓存过期策略改为“可观测不可交易”**
   - 当缓存 `age > ORDERBOOK_STALE_AFTER_SEC` 且持续超时，ask 不再直接参与交易覆盖；
   - 进入观察态，等待 fresh WS 或 REST 多次一致确认后恢复交易。

## 现场核验建议（你下一轮可直接执行）
1. 对同一 token 抓取 20 次“校验覆盖前后”的 REST 原始 orderbook JSON（保存原文）。
2. 记录提取路径（例如 `asks[0].price`）并与最终 `validated_price` 对比。
3. 同步记录当时 WS `best_bid/best_ask/cache_age/seq`。
4. 若 REST 原始就是 0.99/0.999，归类为“上游脏盘口/极端盘口”；若 REST 原始不是 0.99/0.999 但提取后是，则归类为“解析误命中”。

